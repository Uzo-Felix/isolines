<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Isolines Visualizer</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #ffffff;
        }
        
        #map {
            height: 100vh;
            width: 100%;
            background: #fff;
        }
        
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .file-input {
            margin-bottom: 10px;
        }
        
        .info-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-width: 300px;
        }
        
        .legend {
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 4px;
            margin-right: 8px;
        }

        /* Enhanced styling for better isoline visibility */
        .leaflet-path-pane path {
            stroke-width: 3px !important;
            stroke-opacity: 0.9 !important;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
        }

        /* Remove map tiles styling since we don't need it */
        .leaflet-tile-pane {
            display: none;
        }
    </style>
</head>
</head>
<body>
    <div class="controls">
        <div class="file-input">
            <label for="geojson-file">Load GeoJSON:</label>
            <input type="file" id="geojson-file" accept=".geojson,.json" />
        </div>
        <button onclick="loadDefaultGeoJSON()">Load Default Isolines</button>
        <button onclick="clearMap()">Clear Map</button>
    </div>
    
    <div class="info-panel">
        <h4>Isolines Viewer</h4>
        <div id="feature-count">No data loaded</div>
        <div class="legend" id="legend"></div>
    </div>
    
    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    
    <script>
        // Initialize the map
        let map = L.map('map').setView([0, 0], 2);
        let geojsonLayer = null;
        
        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);
        
        // Color palette for different isolines
        const colors = [
            '#FF0000', '#FF4500', '#FFA500', '#FFD700', '#FFFF00',
            '#ADFF2F', '#00FF00', '#00CED1', '#0000FF', '#4169E1',
            '#8A2BE2', '#FF1493', '#DC143C', '#B22222', '#8B0000'
        ];
        
        // Function to get color based on feature properties
        function getFeatureColor(feature, index) {
            // Try to use elevation/value property for coloring
            if (feature.properties && feature.properties.elevation) {
                const elevation = feature.properties.elevation;
                const hue = ((elevation % 360) + 360) % 360;
                return `hsl(${hue}, 70%, 50%)`;
            }
            // Fallback to index-based coloring
            return colors[index % colors.length];
        }
        
        // Function to style GeoJSON features
        function styleFeature(feature, index) {
            return {
                color: getFeatureColor(feature, index),
                weight: 2,
                opacity: 0.8
            };
        }
        
        // Function to add popup to features
        function onEachFeature(feature, layer) {
            if (feature.properties) {
                let popupContent = '<div><strong>Isoline Properties:</strong><br>';
                for (const [key, value] of Object.entries(feature.properties)) {
                    popupContent += `<strong>${key}:</strong> ${value}<br>`;
                }
                popupContent += '</div>';
                layer.bindPopup(popupContent);
            }
        }
        
        // Function to load GeoJSON data
        function loadGeoJSON(geojsonData) {
            // Clear existing layer
            if (geojsonLayer) {
                map.removeLayer(geojsonLayer);
            }
            
            // Add new GeoJSON layer
            geojsonLayer = L.geoJSON(geojsonData, {
                style: function(feature) {
                    const index = geojsonData.features.indexOf(feature);
                    return styleFeature(feature, index);
                },
                onEachFeature: onEachFeature
            }).addTo(map);
            
            // Fit map to data bounds
            if (geojsonLayer.getBounds().isValid()) {
                map.fitBounds(geojsonLayer.getBounds());
            }
            
            // Update info panel
            updateInfoPanel(geojsonData);
            
            // Update legend
            updateLegend(geojsonData);
        }
        
        // Function to update info panel
        function updateInfoPanel(geojsonData) {
            const featureCount = geojsonData.features.length;
            document.getElementById('feature-count').innerHTML = 
                `Features loaded: ${featureCount}`;
        }
        
        // Function to update legend
        function updateLegend(geojsonData) {
            const legend = document.getElementById('legend');
            legend.innerHTML = '<strong>Isolines:</strong>';
            
            geojsonData.features.slice(0, 10).forEach((feature, index) => {
                const color = getFeatureColor(feature, index);
                const value = feature.properties?.elevation || 
                             feature.properties?.value || 
                             `Line ${index + 1}`;
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${color}"></div>
                    <span>${value}</span>
                `;
                legend.appendChild(legendItem);
            });
            
            if (geojsonData.features.length > 10) {
                const moreItem = document.createElement('div');
                moreItem.innerHTML = `... and ${geojsonData.features.length - 10} more`;
                legend.appendChild(moreItem);
            }
        }
        
        // Function to load default GeoJSON file
        async function loadDefaultGeoJSON() {
            try {
                const response = await fetch('./output/isolines.geojson');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const geojsonData = await response.json();
                loadGeoJSON(geojsonData);
            } catch (error) {
                alert('Error loading default GeoJSON file: ' + error.message);
                console.error('Error:', error);
            }
        }
        
        // Function to clear map
        function clearMap() {
            if (geojsonLayer) {
                map.removeLayer(geojsonLayer);
                geojsonLayer = null;
            }
            document.getElementById('feature-count').innerHTML = 'No data loaded';
            document.getElementById('legend').innerHTML = '';
        }
        
        // File input handler
        document.getElementById('geojson-file').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const geojsonData = JSON.parse(e.target.result);
                        loadGeoJSON(geojsonData);
                    } catch (error) {
                        alert('Error parsing GeoJSON file: ' + error.message);
                        console.error('Error:', error);
                    }
                };
                reader.readAsText(file);
            }
        });
        
        // Try to load default GeoJSON on page load
        window.addEventListener('load', function() {
            // Uncomment the next line if you want to auto-load the default file
            loadDefaultGeoJSON();
        });
    </script>
</body>
</html>